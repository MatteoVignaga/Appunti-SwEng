Lab01 - Doubly Linked List con Gab ------------------------------------------------------------------------------------------------------------------------------------------------------
In questo lab abbiamo dato un'occhiata generale ai tool del corso: git, gradle, intellij.
L'esercizio è molto semplice: implementare una doubly linked list con funzioni di push, pop, shift e unshift.
Un concetto su cui ci siamo soffermati è il "million dollar problem": come gestire i valori nulli. Per farlo, esistono varie metodologie:
- Metodo sconsigliato: ammettere valori nulli (pericoloso);
- Programmazione difensiva: non ammettere valori nulli dando la responsabilità del controllo al codice (che quindi si "difende" dai valori nulli). Per farlo si può utilizzare una semplice condizione (val != null), oppure Objects.requireNonNull(val).
- Programmazione basata su contratti: non ammettere valori nulli dando la responsabilità del controllo al chiamante, sfruttando le notazioni di Intellij @NotNull oppure tramite assert(val != null).

Piccolo approfondimento delle notazioni di Intellij: nullability.
Le notazioni @Nullable e @NotNull sono notazioni che permettono di trovare bug ed inconsistenze nella gerarchia di dati tramite la Code Inspection di Intellij, che informa sulle discrepanze quando possibile.

La notazione @Nullable serve per denotare che un elemento è valido anche quando il suo valore è nullo: 
- per metodi, il valore di ritorno;
- per parametri, il valore passato;
- per variabili, il valore contenuto;
Quando si effettua Override di un metodo @Nullable, il metodo figlio può essere @Nullable o @NotNull. Se i parametri sono @Nullable, i parametri del metodo figlio richiedono @Nullable.


La notazione @NotNull invece annota che sia vietato utilizzare un valore nullo per questo elemento. Quando si effettua Override di un metodo @NotNull, anche il metodo figlio lo richiede. Se i parametri sono @NotNull, i parametri del metodo figlio possono essere @NotNull o @Nullable.

Note su intellij:
- testing con gradle (icona dell'elefantino sulla destra)
- testing con coverage (icona dei tra puntini a fianco al pulsante di run veloce in alto): permette di eseguire un test calcolando quante righe del codice testato vengono utilizzate. Se eseguire tutti i test con coverage non riscontra un utilizzo del 100% del codice, i casi sono 2: o è codice inutile, o serve aggiungere un'unità di test che copra anche quella parte;
- analisi automatica del codice: fornisce hints utili al refactoring





Lab02 - Bowling kata con Alessandro ---------------------------------------------------------------------------------------------------------------------------------------------------
In questo laboratorio il focus è il TDD: fare pratica a rispettare l'ordine dei commit rosso-verde-refactoring.
L'esercizio è risultato relativamente semplice, dilungatosi a causa della nostra gestione errata di spare e strike. Corretto in autonomia la stessa sera in 15 minuti.





Lab03 - Forth Interpreter con Federica ------------------------------------------------------------------------------------------------------------------------------------------------
In questo lab abbiamo iniziato ad usare git in maniera più approfondita tramite gitflow: il lavoro viene scandito tramite feature branches ed abbiamo rilasciato 2 versioni.
1. Innanzitutto, una volta forkato e clonato il repo, si usa git flow init;
2. Poi si fanno le feature: git flow feature start <nome feature>, così da lavorare su un altro branch per ogni funzionalità aggiuntiva, sempre in modalità TDD;
3. Una volta fatte tutte le iterazioni necessarie per finire la feature, si usa git flow feature finish per fare un merge sul branch develop;
4. Una volta finite abbastanza funzionalità da avere un prodotto valido, si può usare git flow release start <nome release> per iniziare un rilascio;
5. Dopo aver fatto eventuali bug fixes si può fare git flow release finish 'nome release' per effettuare un merge da develop nel branch release;
E' importante calibrare adeguatamente la granularità delle feature, non serve iniziare una nuova feature ad ogni nuovo test del TDD. 
Nel nostro caso, abbiamo effettuato una feature per la gestione dei soli numeri ed una feature per ogni operatore/comando da implementare.

Abbiamo anche visto come scrivere i test, sia tramite @Test per test semplici, sia tramite @ParameterizedTest e @CvsSource per test parametrizzati.
  @ParameterizedTest
  @CsvSource({
          "'input1', expected1",
          "'input2', expected2"
  })
  public void test(String input, String output){
    String resul = object.method(input);
    assertThat(result).isEqualTo(output);
  }
In questo modo il test verrà eseguito 2 volte con input differenti, utile per controllare casi differenti dello stesso problema.

Si può fare allo stesso modo per controllare che il codice lanci eccezioni specifiche:
  @ParameterizedTest
  @CsvSource({
          "'input1', expected1",
          "'input2', expected2"
  })
  public void test(String input, String output){
          assertThatThrownBy(
            () -> object.method(input))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage(output);
  }




Lab04 - Poker kata con Alessandro --------------------------------------------------------------------------------------------------------------------------------------------------
In questo lab abbiamo implementato delle basi di un programmino per giocare a poker. Il focus era sul pattern Chain of Responsibility utilizzato per gestire
la valutazione di una mano di un giocatore. A causa di un problema con i commit sui rami feature ho personalmente visto il comando cherry pick.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




Lab05 - Rubamazzetto con Lorenzo ---------------------------------------------------------------------------------------------------------------------------------------------------
In questo lab abbiamo complementato del codice già parzialmente fornito per la gestione di partite a rubamazzetto. Il focus della lezione non mi è sembrato niente
di specifico, solo lavorare. Nel complesso, lab deludente per via del codice fornito dal prof errato, e per via della necessità di utilizzare mockito senza averlo 
trattato abbastanza bene. Ad esempio, era necessario implementare un test che facesse dependency injection e non lo avevamo ancora mai visto.

Durante la lezione di teoria successiva il prof Bellettini ha fatto delle osservazioni:
- planning game
- prestare attenzione a ciò che dicono i professori
- guardare la documentazione di assertj
- guardare la funzione extracting: assertThat(partita).extracting("tavolo.scoperte", as(LIST)).contains(card)
- guardare ciò che abbiamo visto per l'accesso a metodi privati
- …
- un solo exercise per test: io e lorenzo abbiamo testato size() con due assertThat, ma è meglio separarlo in due test, un sizeTest ed un sizeAfterDrawTest
- ERRORACCIO: per size potevamo tenerci un attributo int size inizializzato a 52 (o meglio, alla dimensione iniziale dell'adaptee) e ridotto ad ogni draw

Dependency injection: dichiara dei parametri con @Mock e dichiara l'oggetto in cui devono essere iniettati con @InjectMocks. Il metodo utilizzato da Mockito per l'injection
è diviso in 3 livelli:
1. cerca il costruttore con più parametri che prenda come input un parametro dello stesso tipo;
2.
3.

Mocking del costruttore: 
try (var mocked = Mockito.mockConstruction(Tavolo.class) {
	//...?
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




Lab06 - Tressette a 2 con Riccardo -------------------------------------------------------------------------------------------------------------------------------------------------
Il lab era incentrato sul simulare la difficoltà del parziale che avrà luogo durante il lab 07, difatti si tratta del parziale dell'anno scorso.
Tutto sommato non è stato molto complesso, ma non siamo comunque riusciti a finirlo: anche il prof Bellettini, a lezione, ha menzionato il fatto che 
non è necessario terminare completamente il lavoro, è parte di progettazione andare a valutare quali parti implementare e quali no; terrà più conto del
corretto utilizzo di git e di un'implementazione che rispetti i principi SOLID ed i code smells di cui abbiamo parlato. 


La lezione dopo il prof ha fatto delle considerazioni:
- ci lascia un pochino nell'ignoranza per git perché utilizzerà la storia dei commit per valutarci, se impariamo a "riscrivere la storia" allora tanto vale;
- decidere da dove partire: 
- se mi sono dimenticato di aprire una feature: si può aprire senza problemi
- se mi sono dimenticato di fare commit ROSSO: posso fare un commit selezionando solamente i file di test come i cambiamenti da far rientrare nel commit
- se ho committato il ROSSO ma il test era sbagliato: commit --amend
- se ho committato il ROSSO ma volevo prima aprire un'altra feature: ??
- se ho committato il ROSSO ma volevo fare REFACTORING: creo un'altra feature per il refactoring, commit, poi torno nella feature precedente e posso fare git flow feature rebase per riportare il contenuto della feature precedente in alto. E' simile ad un merge, ma prende tutti i commit della feature corrente e li riesegue come feature che si dirama dall'ultimo commit su develop.



























